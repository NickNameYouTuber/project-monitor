<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC Multi-Peer with Signaling Server and Rooms</title>
    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        video {
            width: 300px;
            height: 200px;
            background-color: black;
            margin: 10px;
        }
        .videos {
            display: flex;
            flex-wrap: wrap;
        }
        input {
            width: 400px;
            margin: 10px 0;
        }
        button {
            margin: 5px;
        }
        label {
            display: block;
            margin-top: 10px;
        }
        .peer-container {
            border: 1px solid #ccc;
            padding: 10px;
            margin: 10px;
        }
        .hidden {
            display: none;
        }
        #status {
            font-weight: bold;
            color: red;
        }
        #status.connected {
            color: green;
        }
    </style>
</head>
<body>
    <h1>WebRTC Multi-Peer with Signaling Server and Rooms</h1>
    <p>Open in multiple tabs. Optionally start local media (choose what to share), join a room (same room ID for group). If no sharing selected, join as viewer (receive only).</p>
    
    <div id="status">Status: Disconnected</div>
    
    <label><input type="checkbox" id="shareCamera" checked> Share Camera and Audio</label>
    <label><input type="checkbox" id="shareScreen" checked> Share Screen</label>
    <button id="startLocal">Start Local Media (or Skip for Viewer Mode)</button>
    
    <div class="videos">
        <div id="localCameraContainer">
            <label>Local Camera</label>
            <video id="localCamera" autoplay playsinline muted></video>
        </div>
        <div id="localScreenContainer">
            <label>Local Screen</label>
            <video id="localScreen" autoplay playsinline muted></video>
        </div>
    </div>
    
    <label>Room ID:</label>
    <input id="roomId" placeholder="Enter room ID (e.g., room1)">
    <button id="joinRoom">Join Room</button>
    
    <h2>Remote Peers</h2>
    <div id="remotes" class="videos"></div>
    
    <script>
        const localCamera = document.getElementById('localCamera');
        const localScreen = document.getElementById('localScreen');
        const localCameraContainer = document.getElementById('localCameraContainer');
        const localScreenContainer = document.getElementById('localScreenContainer');
        const shareCameraCheckbox = document.getElementById('shareCamera');
        const shareScreenCheckbox = document.getElementById('shareScreen');
        const roomIdInput = document.getElementById('roomId');
        const remotesContainer = document.getElementById('remotes');
        const statusDiv = document.getElementById('status');
        
        let localStream = null;
        let roomJoined = false;
        // Connect via relative path through Nginx proxy
        const socket = io('/', { path: '/socket.io' });
        const peers = {}; // Map of peerId to RTCPeerConnection
        
        async function attachLocalToPeersAndRenegotiate() {
            if (!localStream) return;
            const entries = Object.entries(peers);
            for (const [peerId, pc] of entries) {
                if (!pc) continue;
                // Ensure local tracks are added once per kind
                for (const track of localStream.getTracks()) {
                    const hasSender = pc.getSenders().some(s => s.track && s.track.kind === track.kind);
                    if (!hasSender) {
                        try { pc.addTrack(track, localStream); } catch (e) { console.warn('addTrack failed', e); }
                    }
                }
                try {
                    const offer = await pc.createOffer();
                    await pc.setLocalDescription(offer);
                    socket.emit('offer', { to: peerId, offer: pc.localDescription });
                } catch (e) {
                    console.warn('renegotiate failed', e);
                }
            }
        }
        
        // Socket connection handling
        socket.on('connect', () => {
            console.log('Connected to signaling server');
            statusDiv.textContent = 'Status: Connected';
            statusDiv.classList.add('connected');
        });
        
        socket.on('connect_error', (err) => {
            console.error('Connection error:', err.message);
            statusDiv.textContent = `Status: Connection Failed - ${err.message}`;
            alert(`Failed to connect to server: ${err.message}. Check if server is reachable.`);
        });
        
        socket.on('disconnect', () => {
            console.log('Disconnected from signaling server');
            statusDiv.textContent = 'Status: Disconnected';
            statusDiv.classList.remove('connected');
            roomJoined = false;
        });
        
        async function startLocalMedia() {
            let cameraStream = null;
            let screenStream = null;
            const shareCamera = shareCameraCheckbox.checked;
            const shareScreen = shareScreenCheckbox.checked;
            
            if (!shareCamera && !shareScreen) {
                console.log('Joining as viewer (no sharing)');
                localCameraContainer.classList.add('hidden');
                localScreenContainer.classList.add('hidden');
                return; // localStream remains null
            }
            
            try {
                if (shareCamera) {
                    cameraStream = await navigator.mediaDevices.getUserMedia({
                        video: true,
                        audio: true
                    });
                    localCamera.srcObject = cameraStream;
                } else {
                    localCameraContainer.classList.add('hidden');
                }
                
                if (shareScreen) {
                    screenStream = await navigator.mediaDevices.getDisplayMedia({
                        video: true
                    });
                    localScreen.srcObject = screenStream;
                    screenStream.getVideoTracks()[0].onended = () => {
                        console.log('Screen sharing stopped');
                    };
                } else {
                    localScreenContainer.classList.add('hidden');
                }
                
                localStream = new MediaStream([
                    ...(cameraStream ? cameraStream.getTracks() : []),
                    ...(screenStream ? screenStream.getTracks() : [])
                ]);
                // attach to existing peer connections and renegotiate
                await attachLocalToPeersAndRenegotiate();
            } catch (error) {
                console.error('Error getting media:', error);
                if (cameraStream) cameraStream.getTracks().forEach(t => t.stop());
                if (screenStream) screenStream.getTracks().forEach(t => t.stop());
                localStream = null;
            }
        }
        
        async function joinRoomFunc() {
            const roomId = roomIdInput.value.trim();
            if (!roomId) {
                alert('Enter a room ID');
                return;
            }
            if (!socket.connected) {
                alert('Not connected to server. Check server status.');
                return;
            }
            // If user intends to share, ensure media is started before joining
            if ((shareCameraCheckbox.checked || shareScreenCheckbox.checked) && !localStream) {
                await startLocalMedia();
            }
            console.log(`Joining room: ${roomId}`);
            socket.emit('joinRoom', roomId);
            roomJoined = true;
            statusDiv.textContent = `Status: Connected - In Room ${roomId}`;
        }
        
        function createPeerConnection(peerId) {
            console.log(`Creating peer connection for ${peerId}`);
            const pc = new RTCPeerConnection({
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'turn:nit.nicorp.tech:3478', username: 'test', credential: 'test' }
                ]
            });
            
            pc.onicecandidate = (event) => {
                if (event.candidate) {
                    console.log(`Sending candidate to ${peerId}`);
                    socket.emit('candidate', { to: peerId, candidate: event.candidate });
                }
            };
            
            pc.ontrack = (event) => {
                console.log(`Received track from ${peerId}`);
                handleRemoteStream(peerId, event.streams[0]);
            };
            
            pc.oniceconnectionstatechange = () => {
                console.log(`ICE state for ${peerId}: ${pc.iceConnectionState}`);
                if (pc.iceConnectionState === 'disconnected') {
                    removePeer(peerId);
                }
            };
            
            if (localStream) {
                try { localStream.getTracks().forEach(track => pc.addTrack(track, localStream)); } catch {}
            }
            
            peers[peerId] = pc;
            return pc;
        }
        
        function handleRemoteStream(peerId, remoteStream) {
            console.log(`Handling remote stream from ${peerId}`);
            let peerDiv = document.getElementById('peer-' + peerId);
            if (!peerDiv) {
                peerDiv = document.createElement('div');
                peerDiv.id = 'peer-' + peerId;
                peerDiv.className = 'peer-container';
                peerDiv.innerHTML = `
                    <label>Peer ${peerId} Video 1 (Camera?)</label>
                    <video id="remote-vid1-${peerId}" autoplay playsinline></video>
                    <label>Peer ${peerId} Video 2 (Screen?)</label>
                    <video id="remote-vid2-${peerId}" autoplay playsinline></video>
                `;
                remotesContainer.appendChild(peerDiv);
            }
            
            const vid1 = document.getElementById(`remote-vid1-${peerId}`);
            const vid2 = document.getElementById(`remote-vid2-${peerId}`);
            
            const videoTracks = remoteStream.getVideoTracks();
            const audioTracks = remoteStream.getAudioTracks();
            
            if (videoTracks.length > 0) {
                const audio = audioTracks.length > 0 ? [audioTracks[0]] : [];
                vid1.srcObject = new MediaStream([videoTracks[0], ...audio]);
            }
            if (videoTracks.length > 1) {
                vid2.srcObject = new MediaStream([videoTracks[1]]);
            }
        }
        
        function removePeer(peerId) {
            console.log(`Removing peer ${peerId}`);
            if (peers[peerId]) {
                peers[peerId].close();
                delete peers[peerId];
            }
            const peerDiv = document.getElementById('peer-' + peerId);
            if (peerDiv) peerDiv.remove();
        }
        
        // Socket events
        socket.on('existingUsers', async (users) => {
            console.log(`Existing users in room: ${users.join(', ')}`);
            for (const peerId of users) {
                const pc = createPeerConnection(peerId);
                if (!localStream) {
                    pc.addTransceiver('audio', { direction: 'recvonly' });
                    pc.addTransceiver('video', { direction: 'recvonly' });
                    pc.addTransceiver('video', { direction: 'recvonly' });
                }
                console.log(`Creating offer for ${peerId}`);
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                socket.emit('offer', { to: peerId, offer: pc.localDescription });
            }
        });
        
        socket.on('userJoined', async (peerId) => {
            console.log(`User joined: ${peerId}`);
            createPeerConnection(peerId);
            // New user will initiate offer
        });
        
        socket.on('offer', async ({ from, offer }) => {
            console.log(`Received offer from ${from}`);
            if (!peers[from]) createPeerConnection(from);
            const pc = peers[from];
            await pc.setRemoteDescription(new RTCSessionDescription(offer));
            if (!localStream) {
                pc.getTransceivers().forEach(transceiver => {
                    transceiver.direction = 'recvonly';
                });
            }
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            console.log(`Sending answer to ${from}`);
            socket.emit('answer', { to: from, answer: pc.localDescription });
        });
        
        socket.on('answer', async ({ from, answer }) => {
            console.log(`Received answer from ${from}`);
            const pc = peers[from];
            if (pc) {
                await pc.setRemoteDescription(new RTCSessionDescription(answer));
            }
        });
        
        socket.on('candidate', async ({ from, candidate }) => {
            console.log(`Received candidate from ${from}`);
            const pc = peers[from];
            if (pc) {
                await pc.addIceCandidate(new RTCIceCandidate(candidate));
            }
        });
        
        socket.on('userLeft', (peerId) => {
            console.log(`User left: ${peerId}`);
            removePeer(peerId);
        });
        
        document.getElementById('startLocal').addEventListener('click', startLocalMedia);
        document.getElementById('joinRoom').addEventListener('click', joinRoomFunc);
    </script>
</body>
</html>
