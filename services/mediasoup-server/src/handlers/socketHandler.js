const RoomManager = require('../services/RoomManager');
const Peer = require('../services/PeerManager');

/**
 * Helper: –ù–∞–π—Ç–∏ consumer ID –ø–æ producer ID
 */
function findConsumerIdByProducerId(peer, producerId) {
  for (const [consumerId, consumer] of peer.consumers.entries()) {
    if (consumer.producerId === producerId) {
      return consumerId;
    }
  }
  return null;
}

function setupSocketHandlers(io) {
  io.on('connection', (socket) => {
    console.log(`üîå Client connected: ${socket.id}`);
    
    let currentRoomId = null;
    let currentPeer = null;

    // Join room
    socket.on('mediasoup:join-room', async ({ roomId, rtpCapabilities }, callback) => {
      try {
        console.log(`üë§ ${socket.id} –ø—Ä–∏—Å–æ–µ–¥–∏–Ω—è–µ—Ç—Å—è –∫ –∫–æ–º–Ω–∞—Ç–µ ${roomId}`);
        
        // Create or get room
        let room = RoomManager.getRoom(roomId);
        if (!room) {
          room = await RoomManager.createRoom(roomId);
        }

        // Create peer
        currentPeer = new Peer(socket.id, roomId, room.router);
        room.peers.set(socket.id, currentPeer);
        currentRoomId = roomId;

        // Join socket.io room for broadcasting
        socket.join(roomId);

        // Create transports
        const sendTransportParams = await currentPeer.createSendTransport();
        const recvTransportParams = await currentPeer.createRecvTransport();

        // Get existing producers in room
        const existingProducers = [];
        for (const [peerId, peer] of room.peers.entries()) {
          if (peerId !== socket.id) {
            for (const [kind, producer] of peer.producers.entries()) {
              existingProducers.push({
                peerId,
                producerId: producer.id,
                kind
              });
            }
          }
        }

        callback({
          success: true,
          routerRtpCapabilities: room.router.rtpCapabilities,
          sendTransportParams,
          recvTransportParams,
          existingProducers
        });

        // Notify others about new peer
        socket.to(roomId).emit('mediasoup:peer-joined', {
          peerId: socket.id
        });

        console.log(`‚úÖ ${socket.id} –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏–ª—Å—è –∫ –∫–æ–º–Ω–∞—Ç–µ ${roomId}`);
      } catch (error) {
        console.error('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–µ–Ω–∏–∏ –∫ –∫–æ–º–Ω–∞—Ç–µ:', error);
        callback({ success: false, error: error.message });
      }
    });

    // Connect send transport
    socket.on('mediasoup:connect-send-transport', async ({ dtlsParameters }, callback) => {
      try {
        if (!currentPeer) {
          throw new Error('Peer not initialized');
        }

        await currentPeer.connectSendTransport(dtlsParameters);
        callback({ success: true });
      } catch (error) {
        console.error('‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è send transport:', error);
        callback({ success: false, error: error.message });
      }
    });

    // Connect recv transport
    socket.on('mediasoup:connect-recv-transport', async ({ dtlsParameters }, callback) => {
      try {
        if (!currentPeer) {
          throw new Error('Peer not initialized');
        }

        await currentPeer.connectRecvTransport(dtlsParameters);
        callback({ success: true });
      } catch (error) {
        console.error('‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è recv transport:', error);
        callback({ success: false, error: error.message });
      }
    });

    // Produce (start sending media)
    socket.on('mediasoup:produce', async ({ kind, rtpParameters }, callback) => {
      try {
        if (!currentPeer || !currentRoomId) {
          throw new Error('Peer or room not initialized');
        }

        const producerId = await currentPeer.produce(kind, rtpParameters);

        // Notify others about new producer
        socket.to(currentRoomId).emit('mediasoup:new-producer', {
          peerId: socket.id,
          producerId,
          kind
        });

        callback({ success: true, producerId });
      } catch (error) {
        console.error('‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è producer:', error);
        callback({ success: false, error: error.message });
      }
    });

    // Consume (start receiving media)
    socket.on('mediasoup:consume', async ({ producerId, rtpCapabilities }, callback) => {
      try {
        if (!currentPeer) {
          throw new Error('Peer not initialized');
        }

        const consumerParams = await currentPeer.consume(producerId, rtpCapabilities);
        callback({ success: true, ...consumerParams });
      } catch (error) {
        console.error('‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è consumer:', error);
        callback({ success: false, error: error.message });
      }
    });

    // Resume consumer
    socket.on('mediasoup:resume-consumer', async ({ consumerId }, callback) => {
      try {
        if (!currentPeer) {
          throw new Error('Peer not initialized');
        }

        await currentPeer.resumeConsumer(consumerId);
        callback({ success: true });
      } catch (error) {
        console.error('‚ùå –û—à–∏–±–∫–∞ resume consumer:', error);
        callback({ success: false, error: error.message });
      }
    });

    // Pause consumer
    socket.on('mediasoup:pause-consumer', async ({ consumerId }, callback) => {
      try {
        if (!currentPeer) {
          throw new Error('Peer not initialized');
        }

        await currentPeer.pauseConsumer(consumerId);
        callback({ success: true });
      } catch (error) {
        console.error('‚ùå –û—à–∏–±–∫–∞ pause consumer:', error);
        callback({ success: false, error: error.message });
      }
    });

    // Set consumer preferred layers (for simulcast)
    socket.on('mediasoup:set-consumer-layers', async ({ consumerId, spatialLayer, temporalLayer }, callback) => {
      try {
        if (!currentPeer) {
          throw new Error('Peer not initialized');
        }

        await currentPeer.setConsumerPreferredLayers(consumerId, spatialLayer, temporalLayer);
        callback({ success: true });
      } catch (error) {
        console.error('‚ùå –û—à–∏–±–∫–∞ set consumer layers:', error);
        callback({ success: false, error: error.message });
      }
    });

    // Set consumer priority (for bandwidth management)
    socket.on('mediasoup:set-consumer-priority', async ({ consumerId, priority }, callback) => {
      try {
        if (!currentPeer) {
          throw new Error('Peer not initialized');
        }

        await currentPeer.setConsumerPriority(consumerId, priority);
        callback({ success: true });
      } catch (error) {
        console.error('‚ùå –û—à–∏–±–∫–∞ set consumer priority:', error);
        callback({ success: false, error: error.message });
      }
    });

    // Request key frame
    socket.on('mediasoup:request-keyframe', async ({ consumerId }, callback) => {
      try {
        if (!currentPeer) {
          throw new Error('Peer not initialized');
        }

        await currentPeer.requestConsumerKeyFrame(consumerId);
        callback({ success: true });
      } catch (error) {
        console.error('‚ùå –û—à–∏–±–∫–∞ request keyframe:', error);
        callback({ success: false, error: error.message });
      }
    });

    // Close producer
    socket.on('mediasoup:close-producer', async ({ kind }, callback) => {
      try {
        if (!currentPeer || !currentRoomId) {
          throw new Error('Peer or room not initialized');
        }

        const producer = currentPeer.producers.get(kind);
        if (producer) {
          // Notify others
          socket.to(currentRoomId).emit('mediasoup:producer-closed', {
            peerId: socket.id,
            producerId: producer.id,
            kind
          });

          await currentPeer.closeProducer(kind);
        }

        callback({ success: true });
      } catch (error) {
        console.error('‚ùå –û—à–∏–±–∫–∞ –∑–∞–∫—Ä—ã—Ç–∏—è producer:', error);
        callback({ success: false, error: error.message });
      }
    });

    // Get room stats
    socket.on('mediasoup:get-stats', (callback) => {
      try {
        const stats = RoomManager.getRoomStats();
        callback({ success: true, stats });
      } catch (error) {
        console.error('‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏:', error);
        callback({ success: false, error: error.message });
      }
    });

    // Recreate transport (–¥–ª—è –∞–≥—Ä–µ—Å—Å–∏–≤–Ω–æ–≥–æ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è)
    socket.on('mediasoup:recreate-transport', async ({ type }, callback) => {
      try {
        console.log(`üîÑ Recreating ${type} transport for ${socket.id}`);
        
        if (!currentPeer) {
          throw new Error('Peer not initialized');
        }

        let transportParams;
        if (type === 'send') {
          transportParams = await currentPeer.createSendTransport();
        } else {
          transportParams = await currentPeer.createRecvTransport();
        }

        callback({ success: true, transportParams });
        console.log(`‚úÖ ${type} transport recreated for ${socket.id}`);
      } catch (error) {
        console.error(`‚ùå –û—à–∏–±–∫–∞ –ø–µ—Ä–µ—Å–æ–∑–¥–∞–Ω–∏—è ${type} transport:`, error);
        callback({ success: false, error: error.message });
      }
    });

    // Consumer restart (–¥–ª—è recovery –º–µ—Ä—Ç–≤—ã—Ö —Ç—Ä–µ–∫–æ–≤)
    socket.on('request-consumer-restart', async ({ socketId: targetSocketId }) => {
      try {
        console.log(`üîÑ Consumer restart request from ${socket.id} for ${targetSocketId}`);
        
        if (!currentRoomId) {
          throw new Error('Room not initialized');
        }

        const room = RoomManager.getRoom(currentRoomId);
        if (!room) {
          throw new Error('Room not found');
        }

        // –ù–∞–π—Ç–∏ target peer
        const targetPeer = room.peers.get(targetSocketId);
        if (!targetPeer) {
          console.warn(`‚ö†Ô∏è Target peer ${targetSocketId} not found in room`);
          return;
        }

        // –ü–µ—Ä–µ—Å–æ–∑–¥–∞—Ç—å consumers –¥–ª—è producers —ç—Ç–æ–≥–æ peer
        let recreatedCount = 0;
        targetPeer.producers.forEach(async (producer, kind) => {
          try {
            // –ó–∞–∫—Ä—ã—Ç—å —Å—Ç–∞—Ä—ã–π consumer –µ—Å–ª–∏ –µ—Å—Ç—å
            const oldConsumerId = findConsumerIdByProducerId(currentPeer, producer.id);
            if (oldConsumerId) {
              await currentPeer.closeConsumer(oldConsumerId);
            }

            // –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π consumer
            const { id, kind: consumerKind, rtpParameters } = await currentPeer.consume(
              producer.id,
              producer.rtpCapabilities
            );

            // –£–≤–µ–¥–æ–º–∏—Ç—å –∫–ª–∏–µ–Ω—Ç–∞ –æ –Ω–æ–≤–æ–º consumer
            socket.emit('mediasoup:new-consumer', {
              id,
              producerId: producer.id,
              kind: consumerKind,
              rtpParameters,
              socketId: targetSocketId
            });

            recreatedCount++;
            console.log(`‚úÖ Consumer recreated: ${id} for producer ${producer.id}`);
          } catch (error) {
            console.error(`Failed to recreate consumer for producer ${producer.id}:`, error);
          }
        });

        console.log(`‚úÖ Recreated ${recreatedCount} consumers for ${targetSocketId}`);
      } catch (error) {
        console.error('‚ùå –û—à–∏–±–∫–∞ consumer restart:', error);
      }
    });

    // Leave room / disconnect
    const cleanup = () => {
      if (currentPeer && currentRoomId) {
        console.log(`üëã ${socket.id} –ø–æ–∫–∏–¥–∞–µ—Ç –∫–æ–º–Ω–∞—Ç—É ${currentRoomId}`);
        
        const room = RoomManager.getRoom(currentRoomId);
        if (room) {
          // Notify others
          socket.to(currentRoomId).emit('mediasoup:peer-left', {
            peerId: socket.id
          });

          // Remove peer from room
          room.peers.delete(socket.id);

          // Close peer resources
          currentPeer.close();

          // Close room if empty
          if (room.peers.size === 0) {
            setTimeout(() => {
              const stillEmpty = room.peers.size === 0;
              if (stillEmpty) {
                RoomManager.closeRoom(currentRoomId);
              }
            }, 5000); // Grace period
          }
        }

        currentPeer = null;
        currentRoomId = null;
      }
    };

    socket.on('mediasoup:leave-room', () => {
      cleanup();
    });

    socket.on('disconnect', () => {
      console.log(`üîå Client disconnected: ${socket.id}`);
      cleanup();
    });
  });
}

module.exports = setupSocketHandlers;

